"""Base strategy abstract class"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum


class SignalType(str, Enum):
    """Trading signal types"""

    BUY = "buy"
    SELL = "sell"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"
    HOLD = "hold"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""

    signal_type: SignalType
    symbol: str
    price: float
    amount: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 0.5
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """Abstract base class for trading strategies"""

    def __init__(
        self,
        strategy_id: str,
        symbol: str,
        portfolio_value: float = 100000.0,
        paper_trading: bool = True,
    ):
        self.strategy_id = strategy_id
        self.symbol = symbol
        self.portfolio_value = portfolio_value
        self.paper_trading = paper_trading
        self.positions: Dict[str, Any] = {}
        self.trades: list[Dict[str, Any]] = []
        self.performance_metrics: Dict[str, float] = {}

    @abstractmethod
    async def generate_signal(
        self, market_data: Dict[str, Any], current_position: Optional[Dict[str, Any]] = None
    ) -> Optional[TradingSignal]:
        """
        Generate trading signal based on market data

        Args:
            market_data: Dictionary containing current market data (price, candles, indicators, etc.)
            current_position: Current position for this symbol (if any)

        Returns:
            TradingSignal or None if no signal
        """
        pass

    def update_portfolio_value(self, value: float) -> None:
        """Update portfolio value"""
        self.portfolio_value = value

    def add_trade(self, trade: Dict[str, Any]) -> None:
        """Record a trade"""
        self.trades.append(trade)

    def calculate_performance_metrics(self) -> Dict[str, float]:
        """Calculate strategy performance metrics"""
        if not self.trades:
            return {}

        # Calculate basic metrics
        winning_trades = [t for t in self.trades if t.get("pnl", 0) > 0]
        losing_trades = [t for t in self.trades if t.get("pnl", 0) < 0]

        total_pnl = sum(t.get("pnl", 0) for t in self.trades)
        win_rate = len(winning_trades) / len(self.trades) if self.trades else 0.0
        avg_win = sum(t.get("pnl", 0) for t in winning_trades) / len(winning_trades) if winning_trades else 0.0
        avg_loss = sum(t.get("pnl", 0) for t in losing_trades) / len(losing_trades) if losing_trades else 0.0

        # Calculate Sharpe ratio (simplified)
        if len(self.trades) > 1:
            returns = [t.get("pnl", 0) / self.portfolio_value for t in self.trades]
            import statistics

            if len(returns) > 1 and statistics.stdev(returns) > 0:
                sharpe = (statistics.mean(returns) / statistics.stdev(returns)) * (252 ** 0.5)  # Annualized
            else:
                sharpe = 0.0
        else:
            sharpe = 0.0

        self.performance_metrics = {
            "total_pnl": total_pnl,
            "total_pnl_pct": (total_pnl / self.portfolio_value) * 100 if self.portfolio_value > 0 else 0.0,
            "win_rate": win_rate,
            "total_trades": len(self.trades),
            "winning_trades": len(winning_trades),
            "losing_trades": len(losing_trades),
            "avg_win": avg_win,
            "avg_loss": avg_loss,
            "profit_factor": abs(avg_win / avg_loss) if avg_loss != 0 else 0.0,
            "sharpe_ratio": sharpe,
        }

        return self.performance_metrics

    def get_state(self) -> Dict[str, Any]:
        """Get current strategy state"""
        return {
            "strategy_id": self.strategy_id,
            "symbol": self.symbol,
            "portfolio_value": self.portfolio_value,
            "paper_trading": self.paper_trading,
            "positions": self.positions,
            "performance_metrics": self.performance_metrics,
        }

